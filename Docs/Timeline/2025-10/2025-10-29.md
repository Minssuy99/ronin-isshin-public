# 2025-10-29

<br>

- [목표](#목표)
- [구현](#구현)
    - [PlayerController.cs](#PlayerController.cs)
    - [PlayerMovement.cs](#PlayerMovement.cs)
    - [PlayerGroundChecker.cs](#PlayerGroundChecker.cs)
    - [PlayerAttack.cs](#PlayerAttack.cs)
    - [PlayerAnimationController.cs](#PlayerAnimationController.cs)
- [커밋](#커밋)

<br>

## 목표

- 공격 기능 `Input System` 으로 전환
- `PlayerController.cs` 리팩토링

<br>

## 구현

### _PlayerController.cs_
```csharp
public enum PlayerState
{
    Idle,
    Moving,
    Jumping,
    Attacking,
}

public class PlayerController : MonoBehaviour
{
    public PlayerState currentState { get; private set; } = PlayerState.Idle;
    
    private PlayerGroundChecker _playerGroundChecker;
    private PlayerMovement _playerMovement;
    private PlayerAttack _playerAttack;

    
    private void Awake()
    {
        _playerGroundChecker = GetComponent<PlayerGroundChecker>();
        _playerMovement = GetComponent<PlayerMovement>();
        _playerAttack = GetComponent<PlayerAttack>();
    }
    void Update()
    {
        UpdateState();
    }

    private void FixedUpdate()
    {
        ControlMovement();
    }

    void UpdateState()
    {
        if (_playerAttack.isAttacking)
        {
            currentState = PlayerState.Attacking;
            return;
        }
        
        switch (currentState)
        {
            case PlayerState.Jumping:
                if (_playerGroundChecker.isGrounded)
                {
                    currentState = PlayerState.Idle;
                }
                break;
            case PlayerState.Idle:
                if (Mathf.Abs(_playerMovement.MoveInput.x) > 0.1f)
                {
                    currentState = PlayerState.Moving;
                }
                break;
            case PlayerState.Moving:
                if (Mathf.Abs(_playerMovement.MoveInput.x) <= 0.1f)
                {
                    currentState = PlayerState.Idle;
                }
                break;
            case PlayerState.Attacking:
                if (Mathf.Abs(_playerMovement.MoveInput.x) > 0.1f)
                {
                    currentState = PlayerState.Idle;
                }
                break;
        }
    }
    void ControlMovement()
    {
        if (_playerAttack.isAttacking)
        {
            _playerMovement.SetMovementEnabled(false);
            _playerMovement.SetFlipEnabled(false);
        }
        else
        {
            _playerMovement.SetMovementEnabled(true);
            _playerMovement.SetFlipEnabled(true);
        }
    }
}
```
<br>

### _PlayerMovement.cs_
```csharp
public class PlayerMovement : MonoBehaviour
{
    [SerializeField] private float moveSpeed = 8.0f;
    [SerializeField] private float jumpForce = 15.0f;

    public Vector2 MoveInput { get; private set; }
    
    private Rigidbody2D _rb;
    private PlayerGroundChecker _playerGroundChecker;
    private bool _movementEnabled = true;
    private bool _flipEnabled = true;

    private void Awake()
    {
        _rb = GetComponent<Rigidbody2D>();
        _playerGroundChecker = GetComponent<PlayerGroundChecker>();

    }
    private void Update()
    {
        UpdateFlip();
    }
    private void FixedUpdate()
    {
        if (_movementEnabled)
        {
            _rb.linearVelocity = new Vector2(MoveInput.x * moveSpeed, _rb.linearVelocity.y);
        }
        else
        {
            _rb.linearVelocity = new Vector2(0f, _rb.linearVelocity.y);
        }
    }
    void UpdateFlip()
    {
        if (!_flipEnabled) return;

        if (MoveInput.x > 0)
        {
            transform.localScale = new Vector2(1, 1);
        }
        else if (MoveInput.x < 0)
        {
            transform.localScale = new Vector2(-1, 1);
        }
    }
    void OnMove(InputValue value)
    {
        MoveInput = value.Get<Vector2>();
    }
    void OnJump()
    {
        if (_playerGroundChecker.isGrounded)
        {
            _rb.linearVelocity = new Vector2(_rb.linearVelocity.x, jumpForce);
        }
    }
    public void SetMovementEnabled(bool enabled)
    {
        _movementEnabled = enabled;
    }

    public void SetFlipEnabled(bool enabled)
    {
        _flipEnabled = enabled;
    }
}
```
<br>

### _PlayerGroundChecker.cs_
```csharp
public class PlayerGroundChecker : MonoBehaviour
{
    public bool isGrounded { get; private set; }
    void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.gameObject.CompareTag("Ground"))
            isGrounded = true;
    }
    void OnCollisionExit2D(Collision2D collision)
    {
        if (collision.gameObject.CompareTag("Ground"))
        {
            isGrounded = false;
        }
    }
}
```
<br>

### _PlayerAttack.cs_
```csharp
public class PlayerAttack : MonoBehaviour
{
    [SerializeField] private BoxCollider2D hitBox;
    private PlayerGroundChecker _playerGroundChecker;
    private Animator _animator;
    
    public bool isAttacking { get; private set; } = false;

    private void Awake()
    {
        _playerGroundChecker = GetComponent<PlayerGroundChecker>();
        _animator = GetComponent<Animator>();
    }

    void OnAttack()
    {
        if (!isAttacking && _playerGroundChecker.isGrounded)
        {
            _animator.SetTrigger("isAttack");
            StartCoroutine(AttackCoroutine());
        }
    }

    IEnumerator AttackCoroutine()
    {
        isAttacking = true;
        
        yield return new WaitForSeconds(0.2f);
        
        isAttacking = false;
    }
    
    /* Animation Events */
    public void EnableHitbox()
    {
        hitBox.enabled = true;
    }

    /* Animation Events */
    public void DisableHitbox()
    {
        hitBox.enabled = false;
    }
}
```
<br>

### _PlayerAnimationController.cs_
```csharp
public class PlayerAnimationController : MonoBehaviour
{
    private Rigidbody2D _rb;
    private Animator _animator;
    private PlayerGroundChecker _playerGroundChecker;
    private PlayerController _playerController;
    private void Awake()
    {
        _rb = GetComponent<Rigidbody2D>();
        _animator = GetComponent<Animator>();
        _playerGroundChecker = GetComponent<PlayerGroundChecker>();
        _playerController = GetComponent<PlayerController>();
    }

    private void Update()
    {
        UpdateMovementAnimation();
        UpdateJumpAnimation();
    }

    void UpdateMovementAnimation()
    {
            if(_playerController.currentState == PlayerState.Moving)
                _animator.SetBool("isRun", true);
            else
                _animator.SetBool("isRun", false);
    }
    
    void UpdateJumpAnimation()
    {
        _animator.SetFloat("yVelocity", _rb.linearVelocity.y);
        
        _animator.SetBool("isGrounded", _playerGroundChecker.isGrounded);
    }
}
```
<br>

## 커밋
- [refactor: Player 컴포넌트 기반 리팩토링](https://github.com/Minssuy99/ronin-isshin-public/commit/05c4c41621a1fbff544fe3820a53ad3f959630af)

<br>
<br>
<br>

[← 이전 글](2025-10-28.md) | [다음 글 →](2025-10-30.md)